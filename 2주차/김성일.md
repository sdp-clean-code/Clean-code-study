# Chapter 3 : 함수

## 작게 만들어라

- 함수를 만드는 첫째 규칙 -> "작게"
  - 둘째 규칙 -> "더 작게"
- 근거는 필자의 지금까지의 경험과 시행착오.

### 블록과 들여쓰기

중첩 구조가 생길만큼 함수가 커지면 안된다.

함수에서 들여쓰기 수준은 1단이나 2단을 넘어서지 말자. => 이를 통해 읽기 쉽고 이해하기 쉽다.

## 한가지만 해라

> 함수는 한 가지를 해야한다. 그 한 가지를 잘해야하고 한 가지만 해야한다. ( SRP 같은 규칙을 생각하자. )

한 가지만 하는 지 판단하는 방법 -> 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면, 그 함수는 여러가지 일을 하는 중.

### 함수 내 섹션

한 기지 작업만하는 함수는 자연스럽게 섹션으로 나누기 어렵다. 그렇기 때문에 섹션이 나뉘지 않도록하자.

## 함수 당 추상화 수준은 하나로

함수가 확실하게 하나의 일만하기위해서는, 함수내 추상화 수준이 동일해야한다.

함수 내에 추상화 수준을 섞지말자. -> 근본 개념과 세부사항이 뒤섞이기 시작하면, 깨어진 창문과 같이 함수에 세부사항이 점점 추가 된다.

> 깨진 창문 이론 : 깨진 유리창 하나를 방치해 두면, 그 지점을 중심으로 범죄가 확산되기 시작한다는 이론으로, 사소한 무질서를 방치하면 큰 문제로 이어질 가능성이 높다는 의미를 담고 있다.

### 위에서 아래로 코드 일기 : 내려가기 규칙

코든느 위에서 아래로 이야기처럼 읽혀야 좋다.

한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

> 이것이 내려가기 규칙이다.

언제나 핵심은 "짧으면서 한 가지만 하는" 함수이다.

## Switch 문

switch문과 if-else문은 작게 만들기 힘들다. 또한, 한 가지만 하는 switch문을 만드는 것도 어렵다.

> 다형성을 이용하여, switch문을 저 차원의 클래스에 숨기고 반복하지 않는 방법을 이용하자.

```java
public abstract class Employee {
  public abstract boolean isPayday();
  public abstract Money calculatePay();
  public abstract void deliveryPay(Money pay);
}

public interface EmployeeFactory {
  public Emplolyee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
    switch(r.type){
      case COMISSIONED:
        return new ComissionedEmployee(r);
      case HOURLY:
        return new HourlyEmployee(r);
      case SALARIED:
        return new SalariedEmployee(r);
      default:
        throw new InvalidEmployeeType(r);
    }
  }
}
```

위 코드를 보면, Factory method 패턴을 통해 어떠한 Employee를 생성할 때 외부에 구현체를 숨긴다.

이를 통해, calculatePay라는 함수의 내부 구현을 각 구현체가 구현하도록하고 그것의 세부사항을 숨겨 SRP, OCP를 지키고있다.

## 서술적인 이름을 사용하라

함수가 작고 단순하면 서술적인 이름을 정하기 쉬워진다.

이름이 길어도 괜찮으니, 간단하지만 서술한 이름을 선택하자.

서술적인 이름은 함수가 하는 일을 더 잘 표현하고, 설계도 뚜렷해지므로 나중에 리팩토링 및 개선이 쉬워진다.

일관성 있는 이름을 정하자. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용하자.

## 함수 인수

이상적인 함수의 인수의 개수는 0개이다.

그 다음은 1개, 2개.. 이다.

3개이상은 웬만하면 피하자.

인수는 개념을 이해하기 어렵게 만들고, 코드를 읽는사람이 의미를 해석하게한다.

또한, 함수 이름과 인수 사이에 추상화 수준이다르면 코드를 읽는 사람이 현시점에서 중요하지않은 세부사항을 알게한다.

테스트의 관점

인수가 늘어나면 늘어날 수록 각 함수에 대한 테스트 조합이 많아지게 된다. ( 2^n 씩 늘어난다. )

> 최선은 인수가 없는 경우이며, 차선은 1개인 경우이다.

### 많이 쓰는 단항 형식

함수에 인수를 1개 넘기는 경우의 가장 흔한 경우는 2가지이다.

1. 함수에 질문을 던지는 경우
2. 인수를 무언가로 변경하여 결과를 변환하는 경우

위와 같은 경우가 아니면, 단항 함수는 가급적 피하자.

변환 함수에서 출력 인수를 사용하게 되면 혼란을 일으킨다.

입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.

### 플래그 인수

함수인자로 bool 값을 넘기는 것은 끔찍하다.

결국 함수가 한꺼번에 여러일을 한다는 것을 대놓고 공표하는 것이기 때문이다.

여러개의 함수로 나누자.

### 이항 함수

인수가 2개인 함수는 1개보다 이해하기 어렵다.

무시되는 인수가 존재할 수도 있으며 이해하기 어려울 뿐더러, 순서를 헷갈리는 경우도 많아진다.

ex) `assertEquals(expected, actual)` 의 인수 순서를 헷갈리는 경우

가능하다면 단항함수로 바꾸자.

### 삼항 함수

순서, 주춤거림, 무시 등으로 야기되는 문제가 배로 늘어난다.

삼항 함수를 만들 때는 신중히 고려하자.

### 인수 객체

인수가 2-3개가 필요하다면, 독립적인 클래스 변수로 선언할 가능성을 짚어보자.

눈속임이라 생각할 수 있지만, 개념을 표현하게 되는 클래스로 변경함으로써 가독성을 높이고 이해가 쉬워진다.

### 인수 목록

때때로는 인수의 개수가 가변적인 함수가 존재한다.

하지만 가변 인수를 하나의 List라고 생각하면 그것은 인수의 개수가 생각한 것보다 적다는 것을 알 수 있다.

### 동사와 키워드

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름은 필수적이다.

단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야한다.

혹은, 함수 이름에 키워드를 추가하여 인수의 순서를 추측할 수 있도록 하자.

## 부수 효과를 일으키지 마라.

부수 효과는 함수에서 한 가지를 하겠다고 약속하고 몰래 다른 짓을 하는 것이다.

=> 그러니 일으키지 말도록하자.

함수에서 명시하지 않은 시간적 결합이나 순서 종속성을 초래한다면 그것을 이름에 분명히하라.

### 출력 인수

일반적으로 우리는 인수를 함수 입력으로 해석한다.

어느 정도 프로그래밍 경력이 쌓였다면, 인수를 출력으로 사용하는 함수에 어색함을 느끼자.

각 인수의 메소드를 통해 호출하는 방식을 사용하자.

함수에서 상태를 변경해야한다면, 함수가 속한 객체 상태를 변경하는 행위로 해결하자.

## 명령과 조회를 분리하자.

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.

함수의 의도를 분명히하기 위해 명령과 조회를 분리하여 동작하도록하자.

## 오류 코드보다 예외를 사용하라

명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 위반한다.

오류 코드를 반환하면 호출하는 오류 코드를 곧바로 처리해야한다.

이러한 문제를 없애기 위해 예외를 사용하자.

### try-catch 뽑아내기

try catch를 사용하면 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.

예외를 처리하지않고, 정상 동작과 오류 처리 동작을 분리하자. 코드를 이해하고 수정하기 쉬워진다.

### 오류 처리도 한가지 작업이다.

오류를 처리하는 함수는 오류만 처리해야 마땅하다.

오류 코드를 추가하는 대신 기존 오류를 재사용하자.

오류 코드 대신 예외를 사용하면 새 예외는 결국 Exception 클래스에서 파생된다. 따라서 오류 코드를 사용하는 것보다, 새 예외를 추가하는 것이 낫다.

## 반복하지 마라. DRY!

알고리즘 하나가 반복되게 되면, 그것에 오류가 생기면 모든 함수에서 그것을 수정해야한다.

중복을 제거하자.

## 구조적 프로그래밍

작은 함수에선 구조적 프로그래밍에 얽매이기보다, return, break, continue를 여러 차례 사용해도 좋다.

오히려 때로는 의도를 더 표현하기 쉬워진다. 하지만 goto는 작은 함수에서는 제발 피하자.

## 함수를 어떻게 짜죠?

처음에는 당연히 길고 복잡한 함수일 것이다.

여기에 단위 테스트를 추가하고, 코드를 다듬고 중복을 제거하고 메서드를 줄이고 순서를 바꾸자.

당연히 코드는 테스트를 통과해야한다.

## 결론

프로그래밍의 대가는 시스템을 구현할 프로그램이 아니라 풀어가야할 이야기로 생각한다.

프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다.

이번 장에서는 함수를 잘 만드는 기교를 소개했다.

위의 내용을 명심하여, 정확한 언어로 깔끔하게 같이 맞아 떨어져야 이야기가 풀어가기 쉬워진다는 사실을 기억하자.

# Chapter 4 : 주석

잘 짠 코드에서 주석은 필요악이다.

주석은 의도를 잘 드러내지 못하는 경우가 많고, 거짓말을하는 경우도 많아진다.

부정확한 주석은 아예 없는 주석보다 훨씬 나쁘다. 독자를 현혹하고 오도한다.

코드만이 진실되게 말하고, 정확한 정보를 제공하는 유일한 통로이다.

## 주석은 나쁜 코드를 보완하지 못한다.

주석을 추가하는 대부분의 이유는 코드 품질이 나쁘기 때문이다.

표현력이 풍부하고 깔끔하고 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많은 코드보다 낫다.

## 코드로 의도를 표현하라

코드만으로 의도를 설명하기 어려운 경우가 존재한다.

주석으로 해결하려하지말고, 생각을하고 설명을 함수로 만드는 것이 더 좋다

## 좋은 주석

어떤 주석은 필요하거나 유익하다.

다음의 주석들은 필요하거나 유익하니 한 번 알아보자.

### 법적인 주석

소스 파일 첫 머리에 드러가는 저작권 정보와 소유권 정보는 필요하고 타당하다.

### 정보를 제공하는 주석

때로는 기본적인 정보를 제공하는 주석은 편리하다.

하지만, 가능하다면 함수 이름에 정보를 담는 편이 더 좋다.

### 의도를 설명하는 주석

때떄로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.

이러한 결정에 깔린 의도를 설명하는 주석은 의도를 분명히 표현한다.

### 의미를 명료하게밝히는 주석

때때로 모호한 인수나 반환값은 그 의미를 읽기 좋게 표현하면 이해하기 쉽다.

인수나 반환값 자체를 명확하게 만들면 더 좋겠지만, 변경하지 못하는 코드라면 그것을 주석을 통해 의미를 명료하게 하면 좋다.

하지만 주석은 항상 그릇될 수 있기 때문에, 고심하여 각별히 주의하자.

### 결과를 경고하는 주석

때로 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다.

이러한 경고 의도는 프로그래머가 실수를 면할 수 있는 기회를 준다.

### TODO 주석

앞으로 할 일을 TODO 주석을 통해 남겨두면, ide를 통해 다음에 쉽게 파악할 수 있으며 다른이에게 도움을 요구하기도 편해진다.

그래도 TODO로 떡칠한 코드는 옳지않다. 주기적으로 삭제하자.

### 중요성을 강조하는 주석

때로는 대수롭지않다고 여길 수 있는 부분을 강조해주는 주석도 괜찮다. 이러한 부분은 다른사람에게 중요성을 상기시켜준다.

### 공개 API에서 Javadocs

설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다.

공개 API를 작성한다면, 훌륭한 Javadocs를 꼭 작성하자.

## 나쁜 주석

대다수 주석이 이 범주에 속한다. 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나 합리화한다.

### 주절 거리는 주석

특별한 이유 없이 의무감으로 혹은 하라고하니까 마지못해 주석을 다는 것은 시간 낭비이다.

주석을 달아야한다면 충분히 시간을 들여 최고의 주석을 달자.

### 같은 이야기를 중복하는 주석

주석이 코드 내용을 그대로 중복하게 되면, 코드를 읽는 것보다 주석을 읽는 것이 더 오래걸릴 수 있다.

이러한 주석은 더 많은 정보를 제공하지 못한다. 하지말자.

### 오해할 여지가 있는 주석

의도는 좋았으나 프로그래머가 엄밀하게 주석을 달지 못하는 경우가 있다.

이러한 주석은 잘못된 정보로 인해 다른 사람을 현혹하고 문제를 발생시킬 수 있다.

### 의무적으로 다는 주석

의무감에 다는 주석은 코드를 복잡하게하고, 혼동과 무질서를 초래한다.

잘못된 정보를 제공할 수 있으니 조심하자.

### 이력을 기록하는 주석

모듈을 편집할 때 그 편집내용을 기록하는 로그와 같은 주석은 현재 VCS가 있는 상태에서는 필요없을 뿐이다.

사용하지말자.

### 있으나마나한 주석

너무나 당연한 사실을 언급하고 새로운 정보를 주지못하는 주석은 쓰지말자.

있으나마나한 주석을 쓸 바에 코드를 정리하자.

### 무서운 잡음

필요없는 욕심으로 추가하는 의미없는 주석은 잡음이나 다름없다.

독자가 얻을 수 있는 이득이 없는 주석은 쓰지말자.

### 함수나 변수로 표현할 수 있다면, 주석을 달지말자.

말 그대로.

코드로 의도를 적절히 표현할 수 있다면, 주석을 쓰지말자.

### 위치를 표현하는 주석

특정 위치를 표현하기 위해 사용하는 주석은 가독성만 낮추고, 잡음이 될 가능성이 높다.

이러한 배너와 같은 주석은 반드시 필요할 때만, 아주 드물게 사용하는 편이 좋다.

### 닫는 괄호에 다는 주석

닫는 괄호에 주석은 큰 함수에서 도움이 될 지 모르지만, 우리가 앞서 배웠던 작은 함수에서는 큰 도움이 되지 못한다.

쓰지 말고, 함수를 줄이려 노력하자.

### 공로나 저자를 표시하는 주석

VCS는 누가 코드를 작성하고 수정했는지 귀신같이 알아낸다.

쓸모없다.

### 주석으로 처리한 코드

주석으로 처리된 코드는 다른 사람들이 지우기를 주저하게하고, 이유가 있으니 남겨놨겠지라는 생각을하게 한다.

이러한 질나쁜 코드가 점점 쌓이면 문제를 일으킨다. 그냥 코드를 삭제하자. 필요한 경우 VCS를 통해 복구하자

### HTML 주석

보기 어렵고, 해석도 안된다 쓰지말자.

### 전역 정보

주석을 달아야한다면 근처에 있는 코드만 기술하자.

일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지마라.

### 너무 많은 정보

주석에다 흥미로운 역사나 관련없는 정보를 나열하지마라.

쓸모 없는 정보이다.

### 모호한 관계

주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야한다.

공들여 주석을 달았다면, 독자가 이해는해야하지 않겠는가?

주석 자체가 설명을 다시 요구하게하면 그것은 잘못된 코드이다.

### 함수 헤더

주석으로 헤더를 단 함수보다, 짧고 한가지만하는 함수가 좋다.

### 비공개 코드에서 Javadocs

공개 API가 아닌 경우 Javadocs는 쓸모 없다.

보기만 싫고 산만해질뿐이다.
